// These groups should gather information strongly related portions of the code.
// In them we aim to explain to other developers:
// - The rationale of the design
// - How careful someone has to be when modifying it
// - Specific naming or other conventions upheld in the code

/**

@defgroup DataContext Data Context
@{
  @brief Generalized and extensible static polymorphisc data holder.

  A data context is a generic form to pass around arbitrary amount of data following
  a defined interface. Moreover, a data context is always extensible to hold more data.
  It has a very similar concept and use cases as `**kwargs` in python. It is called
  context because the content of the object depends on the context where it was called.

  A data context knows at comile-time whether it contains a type identified
  with certain signature.
  ```c++
  template<class Ctx>
  void foo(Ctx&& ctx)
  {
    using GV = ...;
    // check whether context contains the type GV
    constexpr bool result = Ctx::has( Context::Tag<GV>{} );

    // Get a view on the value GV contained in the context
    const auto& view = ctx.view( Context::Tag<GV>{} );

    // Create a new context containing a value 10 for the type `int`
    // Notice that the old context got moved into the new one
    auto new_ctx = Context::DataContext<Ctx,int>{10,std::move(ctx)};

    // move the value contained in `int` outside of the context
    auto value = new_ctx.get( Context::Tag<int>{} );

    // If not sure what types a data context contain, one can print them with
    // Notice that it does not give information whether the data is valid or not
    std::cout << "Output: " << new_ctx << std::endl
    // Output: <data contained in ctx>, int;
  }
  ```

  It's important to notice that this is also possible with variadic templates or
  tuples, however, they usually involve a lot of template metaprogramming to identify
  types and to add more types to it.
@}

*/